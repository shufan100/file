<!DOCTYPE html>
<html>
<head>
	<title>模拟new</title>
</head>
<body>
	
</body>
</html>
<script type="text/javascript">

	

	function Otaku (name, age) {
	    this.name = name;
	    this.age = age;

	    this.habit = 'Games';
	}
	// 因为缺乏锻炼的缘故，身体强度让人担忧
	Otaku.prototype.strength = 60;

	Otaku.prototype.sayYourName = function () {
	    console.log('I am ' + this.name);
	}
	// 原始new一个函数1111111111111111111111111
	// var person = new Otaku('Kevin', '18');

	// 手写new222222222222222222222222222222
	function objectFactory() {

	    var obj = new Object();  // 用new Object() 的方式新建了一个对象 obj
	    console.log(arguments)
	    var Constructor = [].shift.call(arguments); //取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
	    obj.__proto__ = Constructor.prototype; //将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性
	    Constructor.apply(obj, arguments); //使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性
	    var ret = Constructor.apply(obj, arguments);
    	return typeof ret === 'object' ? ret : obj; //需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么
	    // return obj; //返回 obj
	};

	var person = objectFactory(Otaku, 'Kevin222', '18')



	console.log(person.name) // Kevin
	console.log(person.habit) // Games
	console.log(person.strength) // 60

	person.sayYourName(); // I am Kevin


</script>