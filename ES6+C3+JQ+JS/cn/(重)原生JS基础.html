<!DOCTYPE html>
<html>
<head>
	<title>原生JS基础</title>
</head>
<body>
	<h3>1、数据类型之间的区别</h3>
	<ul>
		<div  style="color: blue">1-1、webkit底层运行机制</div>
		<li>
			<span style="color:deeppink">1-1-1、底层渲染过程</span>
			<ul>
				<li>1、在浏览器打开页面，浏览器引擎会渲染相关的代码（包含JS代码）,会把代码至上而下执行</li>
				<li>2、浏览器执行代码会提供一个代码执行环境，这个环境叫做EStack ==》 栈内存stack</li>
				<li>3、开始执行代码，最开始执行的的是全局代码，所以会形成一个EC(CLOBAL)全局上下文，在栈内存中执行全局的代码</li>
				<li>4、在全局的执行上下文有VO(CLOBAL)全局变量对象。可以把定义的变量和对呀的值存到这里</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">1-1-2、内存的概念</span>
			<ul>
				<li>stack栈内存：1.类似内存条（内存小）。2.作用是供代码至上而下执行，存基本类型值。3.存放基本类型(undefined/null/boolean/number/string)</li>
				<li>Heap堆内存：1.类似硬盘（内存大）。2.作用是供代码至上而下执行,存引用类型值。3.存放引用类型（obj）</li>
				<li>所谓堆栈内存，其实就是在计算机内存中分配出来的一块空间，用来执行和存储代码的</li>
			</ul>
		</li>

		<div  style="color: blue">1-2、基本数据类型（值类型）</div>
		<li>
			<span style="color:deeppink">1-2-1、let a = 12; 浏览器解析创建变量过程和存储 （顺序不能颠倒）</span>
			<ul>
				<li>1、创建一个12的值（基本类型存放栈内存，引用类型(obj,fun)存放堆内存）</li>
				<li>2、创建一个变量a,存储到vo中</li>
				<li>3、让创建的a和创建的值12关联一起==》赋值</li>
			</ul>
		</li>

		<div style="color: blue">1-3、引用数据类型（对象函数）</div>
		<li>
			<span style="color:deeppink">1-3-1、let n = {...}; 浏览器解析创建对象过程和存储 （顺序不能颠倒）</span>
			<ul>
				<li>1、创建值，开辟堆内存（Heap），每个堆内存都有一个16进制的地址。把对象中的键值分别存到堆内存中。把堆内存的地址存放在栈内存中，用于供变量引用</li>
				<li>2、创建一个变量n</li>
				<li>3、让变量和创建堆内存的地址进行关联</li>
			</ul>
		</li>
	</ul>
	<!-- -------------------------------------------------------------------------------- -->

	<h3>2、function的基础知识</h3>
	<ul>
		<li>1、定义：一个处理事情的方法.2、作用：函数的意义在于封装.3、目的：减少页面中的冗余代码，提高代码的额重复率</li>
		<div  style="color: blue">2-1、函数的两部分</div>
		<li>
			<span style="color:deeppink">2-1-1、创建函数</span>
			<ul>
				<li>1、语法：function 函数名(形参) {...} （例: function add(num){...}）</li>
				<li>2、创建函数过程：1、创建值：1,开辟一个堆内存2,把函数体中的代码当作字符串存储在堆中3,让变量和地址关联</li>
				<li>3、只创建函数其实就是将一堆字符串存储在堆内而已，并没有实际作用</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">2-1-2、执行函数</span>
			<ul>
				<li>1、语法：函数名(实参) （ 例: add(20) ）</li>
				<li>2、目的:把创建的函数执行</li>
				<li>3、依赖条件：栈内存，供代码执行的上下文</li>
				<li>4、执行函数过程：1:创建全新稍微执行上下文，把执行的上下文压缩到栈内存中执行（进栈执行）2：在这个上下中，也存一个AO（变量对象），用来存储当前上下文创建的变量，这些变量是私有变量，除当前上下文可以使用这些变量的值，以为的上下文是不能直接使用私有变量的</li>
				<li>5、当上下文中的代码执行完后，如果该上下文的信息没有被外界占用的情况下，则执行出栈 （释放掉-减少栈内存的空间）</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">2-1-3、arguments</span>
			<ul>
				<li>1、定义：函数内置的实参集合。不管设置形参，是否传递实参，argument始终存在（ES6没有）。只会出现在函数体中。</li>
				<li>2、形式:arguments是一个类数组集合。类似数组，但不是数组，和元素集合HTMLCollection类似</li>
				<li>3、原理：根据索引记录每一个传递进来的实参信息。arguments中包含了所有传递进来的实参信息。length属性代表传递实参的个数</li>
			</ul>
		</li>
		<div  style="color: blue">2-2、返回值return</div>
		<li>1、定义：如果外面想用当前上下文的一些私有信息，则需要函数提供对应的出口，把信息提供给外面使用，而这个出口在函数中称为“返回值return”</li>
		<li>2、作用：基于return把变量的值暴露给外面使用，告知函数体中下面的代码不能执行</li>
		<li>3、注意：return 后面放的一定事变量</li>
		<li>例子：console.log(sum) sum = 函数，打印sum()的话，return就是函数的返回值了</li>
	</ul>
	<!-- -------------------------------------------------------------------------------- -->

	<h3>3、JS中的变量提升机制</h3>
	<ul>
		<div  style="color: blue">3-1、了解名词</div>
		<li>1、变量声明.2、变量定义.3、执行环境栈。4、变量对象</li>
		
		<div  style="color: blue">3-2、变量提升机制</div>
		<li>1、在执行上下文时会默认把所有var 和 function关键字进行声明或者定义</li>
		<li>2、var知识提升声明</li>
		<li>3、function的会提前声明+定义</li>
		
		<div  style="color: blue">3-3、变量提升具体解析</div>
		<li>
			<span style="color:deeppink">3-3-1、变量提升</span>
			<ul>
				<li>代码例子在script</li>
				<li>1、var先声明，function函数先声明+定义</li>
				<li>2、var a</li>
				<li>3、function func(){...} 创建堆内存，把函数体内代码当作字符串存到堆内存中。把堆内存的十六进制地址存到栈内存中。创建变量func于十六进制地址关联.</li>
			</ul>
		</li>
	</ul>
	<!-- -------------------------------------------------------------------------------- -->

	<h3>4、带var和不带var的区别</h3>
	<ul>
		<div  style="color: blue">4-1、全局对象和全局变量对象的区别</div>
		<li>
			<span style="color:deeppink">4-1-1、全局对象GO</span>
			<ul>
				<li>1、浏览器默认会自带很多供JS调取使用的内置api,这些属性方法都在全局对象GO中存储着</li>
				<li>2、在浏览器端，把GO对象赋值给window，在node端把GO赋值给global</li>
				<li>3、区别：是浏览器天生自带的存储属性和方法堆，是一个对象</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">4-1-2、全局变量对象VO</span>
			<ul>
				<li>1、当全局代码执行过程中，会声明一些变量，这些变量存储在全局变量对象VO中</li>
				<li>2、区别：是我们自己写代码创建的变量存储的地方，是栈内存</li>
			</ul>
		</li>

		<div  style="color: blue">4-2、全局执行上下文</div>
		<li>1、在全局执行上下文中，带var和不带var定义值是两套不同的机制</li>
		<li>2、带var。 带var是创建了一个全局变量，存放在全局变量对象VO(G)中。基于var创建变量，会给VO(G)和GO中各自存储一份</li>
		<li>3、不带var。 不带var创建的不是变量，问是全局对象GO（global object）的一个属性</li>
		<li>
			<span style="color:deeppink">4-2-1、输出顺序</span>
			<ul>
				<li>当我们输出这个变量的时候，首先看是否为全局变量，是则输出全局变量的值，不是，则在看是否为全局对象的属性，再不是，则报错！！</li>
				<li>1、先看是否为全局变量对象AO</li>
				<li>2、再看是否为全局对象GO</li>
			</ul>
		</li>

		<div  style="color: blue">4-3、私有执行上下文</div>
		<li>
			<span style="color:deeppink">4-3-1、带var</span>
			<ul>
				<li>在函数里 var x = 100</li>
				<li>在私有上下文的AO(FN)变量对象中声明一个x的私有变量（x是当前上下文的私有变量，和上下文以外的没有必然的联系）</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">4-3-2、不带var</span>
			<ul>
				<li>在函数里 y = 200</li>
				<li>1、浏览器发现y不是私有变量。则向上级上下文查找，如果上级没有则继续查找，一直到全局上下文为止找到哪一级就是哪一级的变量</li>
				<li>2、如果周到全局没有，则给GO(window)设置一个属性: window.y = 200</li>
			</ul>
		</li>
	</ul>
	<!-- -------------------------------------------------------------------------------- -->

	<h3>5、作用域和作用域链查找机制</h3>
	<ul>
		<div  style="color: blue">5-1、全局/私有变量</div>
		<li>1、全局变量：在全局上下文EC(G)中的全局变量对象VO(G)中，存储的变量</li>
		<li>
			<span style="color:deeppink">2、私有变量</span>
			<ul>
				<li>1、在函数执行形成的私有上下文EC中的变量对象AOz中，存储的变量</li>
				<li>2、包括：当前函数执行形成的上下文:声明过的变量或者函数</li>
			</ul>
		</li>

		<div  style="color: blue">5-2、作用域的概念</div>
		<li>1、在某一个上下文中创建的函数，除了开辟内存和赋值之外，还会给当前函数设置一个作用域属性</li>
		<li>2、当前函数 = 当前安徽尿素创建时候所在的上下文</li>
		<li>3、当前函数的作用域取决于当前函数创建时候的上下文，它在哪个上下文创建的，他的作用域就是谁</li>

		<div  style="color: blue">5-3、作用域链查找机制</div>
		<li>
			<span style="color:deeppink">5-3-1、作用域链的概念</span>
			<ul>
				<li>1、scopeChain:当前EC，函数[[scope]]</li>
				<li>2、以此来建立链式关系，之后我们在查找变量的时候，就是按照这个链式关系找</li>
				<li>3、先找自己上下问的，自己没有，按照作用域链向上级作用域找</li>
				<li>4、包含：当前形成的上下文。当前函数对应的scope作用域</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">5-3-2、作用域链的形成</span>
			<ul>
				<li>1、作用域链是在函数执行的时候形成的</li>
				<li>2、函数的执行步骤：1.创建私有上下文EC(有存放私有变量的变量对象AO) 2.进栈执行(时会把全局上下文压缩到底部) 3.初始化作用域链 scopeChain 当前EC。函数[[scope]] 4.初始化this指向 5.形成赋值(包括初始化arguments) 6.变量提升 7.代码执行 8.执行完可能会出栈(也可能不会出栈)</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">5-3-3、作用域链的查找机制</span>
			<ul>
				<li>在当前上下文中，代码执行的过程中遇到一个变量时，首先看它是否私有的</li>
				<li>1、如果私有的，接下来的所有操作，都是操作自己的，和别人没有关系</li>
				<li>2、如果不是私有的，则按照scopes chain作用域进行查找。子哪个上下文找到，当前变量就是哪个的私有变量</li>
				<li>3、一直找到全局上下文为止</li>
				<li>4、如果找到EC(G)都找不到：如果是获取变量值就会报错。如果是设置值，相当于给GO加属性</li>
			</ul>
		</li>

		<div  style="color: blue">5-4、var a = b = 12; 和 var = 12, b = 12;的区别</div>
		<li>
			<span style="color:deeppink">5-4-1、var a = b = 12;</span>
			<ul>
				<li>1、相当于var a =12, b = 12;</li>
				<li>2、只有第一个带var，第二个不带var</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">5-4-2、var a =12, b = 12;</span>
			<ul>
				<li>1、相当于var a =12, var b = 12;</li>
				<li>2、连续创建多个变量，可以逗号分隔</li>
			</ul>
		</li>
	</ul>
	<!-- -------------------------------------------------------------------------------- -->

	<h3>6、堆栈内存的释放问题</h3>
	<ul>
		<div  style="color: blue">6-1、为什么释放</div>
		<li>1、函数执行就i形成栈内存（从内存中分配的一块空间），如果内存都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就卡死了）</li>
		<li>2、JS中一个重要的性能优化点：减少内存的使用</li>

		<div  style="color: blue">3-2、内存的形式</div>
		<li>
			<span style="color:deeppink">3-2-1、堆内存（HEAP）</span>
			<ul>
				<li>1、堆内存是用来存储引用数据类型值得</li>
				<li>2、形成：创建函数和创建对象就是开辟一个堆内存，吧把代码字符串或键值对存储到堆内存中的</li>
				<li>3、堆内存释放:如果堆内存用完后，我们想去手动释放它，则取消所有的占用，赋值为null（null是空对象指针，也就是不是指向任何的堆内存）</li>
				<li>4、不释放情况：如果有变量或者其他东西存储了堆内存的地址，则当前堆内存被视为占用，也就不能释放销毁</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">3-2-2、栈内存（STACK）</span>
			<ul>
				<li>1、栈内存是用来执行代码和存储解百纳类型值的（创建的变量也存在栈内存中）</li>
				<li>2、形成：全局-打开浏览器形成的全局作用域是栈内存。私有-手动执行函数形成的私有作用域是栈内存。块级-基于ES6的let/const形成的作用域也是栈内存。</li>
				<li>3、栈内存释放：全局栈内存-关掉页面的时候才会销毁。一般情况下，函数只会执行完成，形成的私有栈内存就会被销毁释放掉（排除出现五险极递归、出现死循环的模式）</li>
				<li>4、不释放情况-如果当前上下文的某些内容（一般也是当前上下文中创建的堆）被上下文以外的变量或者其它事务所占用，那么当前上下文就不能出栈释放</li>
			</ul>
		</li>

		<div  style="color: blue">3-3、内存释放机制</div>
		<li>浏览器常用的垃圾回收机制（内存释放机制）</li>
		<li>1、查找引用方式（webilt内核)-浏览器有自动回收垃圾的机制，定期间隔某段时间，把所有没有被占用的内存回收释放（这种垃圾回收机制比其他语言要我完善一些）</li>
		<li>2、内存计数器方式（Trident内核）-当前内存被其他东西引用了，则给堆计数1（累加计数），取消占用后，则减1，当减到零之后，浏览器就可以把它释放了</li>
	</ul>
	<!-- -------------------------------------------------------------------------------- -->

	<h3>7、JS中的闭包机制</h3>
	<ul>
		<div  style="color: blue">7-1、闭包含义</div>
		<li>1、函数执行会形成一个私有上下文的机制就被称为‘闭包’</li>
		<li>2、一般的上下文执行完就出栈销毁了，只有那些没有被销毁的上下文才能被称为'闭包'</li>

		<div  style="color: blue">7-2、闭包作用</div>
		<li>
			<span style="color:deeppink">7-2-1、保护作用</span>
			<ul>
				<li>在这个上下文会有一些私有的变量AO(xx),这些私有变量和外界的变量不会冲突（互不影响）</li>
				<li>1、应用：封装一个插件或者类库等（为了防止定义的变量和用户定义冲突）</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">7-2-2、保存作用</span>
			<ul>
				<li>上下文中的某些内容被外界占用后，当前上下文并不会出栈销毁，这样就会把上下文的一些信息储存起来</li>
				<li>1、应用：我们需要形成以一个闭包，存储一些值（而且不能销毁），这样来供后面的程序运行使用（例：惰性函数、柯里化函数、compose函数dnegJS高阶编程技巧中。就是基于闭包的保存机制实现的）</li>
			</ul>
		</li>

		<div  style="color: blue">7-3、闭包内的值暴露给外面</div>
		<li>1、需求：我们需要把某一个闭包（私有上下文）中的值暴露到外面</li>
		<li>
			<span style="color:deeppink">7-3-2、基于window.xxx=xxx暴露到全局</span>
			<ul>
				<li>这种办法虽然可以实现，但是也会存在冲突，如果我们每一个版块都需要暴露更多的方法。同时都基于这种方法暴露到全局对象GO上，也可能导致方法之间的冲突</li>
				<li>使用：window.queryElment = queryElment;</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">7-3-3、单例设计模式</span>
			<ul>
				<li>1、每一个版块暴露到全局下只有一个变量而已，所有需要供别人调用的方法都在对象中（这样暴露一个或者多个都无所谓）</li>
				<li>2、避免了全局变量的污染，也同时实现了不同闭包之间的方法的公用性</li>
				<li>3、使用：把需要供外面访问的变量和方法，赋值给一个对象，最后返回（外层基于var utils定义变量来接受即可）</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">7-3-4、命名空间</span>
			<ul>
				<li>1、utils对象中包含了需要供别人调取使用的方法，此时我们把utils称之为‘命名空间’，而对象就是一个空间，空间中包含了当前板块中的内容，或者是阿布当前板块中的内容按照命名空间进行分组，每个分组都是一个单独的个体</li>
			</ul>
		</li>

		<div  style="color: blue">7-4、闭包的优缺点</div>
		<li>1、优点：能保护和保存代码不受污染</li>
		<li>2、缺点：因为闭包会产生不能销毁得上下文，这样导致栈/堆内存得消耗过大，有时候会导致内存泄漏等，影响页面得运行性能，所以在真实的项目中，要合理的应用闭包</li>
	</ul>

	<h3>8、面向对象理论基础</h3>
	<ul>
		<div  style="color: blue">8-1、面向对象程序设计中的三大概念</div>
		<li>1、对象：泛指，js中我们操作和研究的是事务都是对象</li>
		<li>2、类：把抽象额对象，按照功能的特点进行详细划分，划分成为很多的类别</li>
		<li>3、实例，每一种类中具体的事务</li>

		<div  style="color: blue">8-2、内置类</div>
		<li>1、根据js中事物的特征，进行类别划分，而默认划分的类别，就是内置类</li>
		<li>2、数据类型中的内置类：number类，string类,boolean类，null/undefined类，symbol类，object对象数据类型类，function类</li>

		<li>JS本身就是按照面向对象思想（类和实例）设计出来的语言，所以我们不论是研究和学习js，还是在工作上进行项目的开发，也都是按照面向对象的思想来学习和开发。</li>
	</ul>

	<h3>9、构造函数创建自定义类</h3>
	<ul>
		<div  style="color: blue">9-1、语法</div>
		<li>
			<span style="color:deeppink">9-1-1、ES3语法</span>
			<ul>
				<li>执行语法——new函数()——这种方式就是基于构造函数的方式来执行的</li>
				<li>约定规范——类名额第一个字母一般都是大写</li>
				<li>特点——1、Func不在被誉为普通函数，而是叫做构造函数2、返回的结果不在是基于return来判断返回值，返回的记过是当前类的一个实例</li>
				<li>想创建自定义类和创建类的实例，只需要在执行的时候不在函数()普通函数执行，而是new 函数()执行，也就是构造函数执行，这样方法被称为类，返回结果被称为类的实例</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">9-1-2、构造函数语法与普通函数语法的区别</span>
			<ul>
				<li>普通函数 —— 函数首字母不大写，函数()调用</li>
				<li>构造函数 —— 函数首字母要大写，new 函数()调用</li>
			</ul>
		</li>

		<div  style="color: blue">9-2、构造函数执行</div>
		<li>构造函数执行（同时拥有普通函数执行的特征，也有自己单独的一些操作）</li>
		<li>
			<span style="color:deeppink">9-2-2、执行步骤</span>
			<ul>
				<li>1、初始化作用域链</li>
				<li>2、形参赋值</li>
				<li>3、变量提升（这三步和普通函数执行时一样的）</li>
				<li>4、首先会在当前上下文中创建一个对象（这个对象就是当前类的实例）（*构造函数执行浏览器默认多做的事情*）</li>
				<li>5、让当前上下文中的this指向新创建的对象（*构造函数执行浏览器默认多做的事情*）</li>
				<li>6、代码执行（把私有变量的值赋值给新创建的实例对象的私有属性）</li>
				<li>7、代码执行，如果我们没有设置return，浏览器会默认把新创建的实例对象返回（*构造函数执行浏览器默认多做的事情*）</li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">9-2-3、实例的相关问题</span>
			<ul>
				<li>1-1、构造函数执行，由于具备普通函数的特征，所以在私有上下文中可能会出现一些私有变量，但是这些私有变量和实例没有必然的的联系</li>
				<li>1-2、私有上下文的this才是实例，所以只能写thsi.xxx = xxx的操作，才是给实例设置私有属性</li>
				<li>1-3、实例的私有属性和上下文的私有变量不是一个东西</li>
				<li>2、当前类的每一个实例都是单独的一个对象，实例和实例之间时独立的</li>
				<li></li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">9-2-4、return相关问题</span>
			<ul>
				<li></li>
			</ul>
		</li>

		<div  style="color: blue">9-3、检测实例的方法</div>
		<li>
			<span style="color:deeppink">9-3-1、instanceof</span>
			<ul>
				<li></li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">9-3-2、hasOwnProperty</span>
			<ul>
				<li></li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">9-3-3、in</span>
			<ul>
				<li></li>
			</ul>
		</li>
		<li>
			<span style="color:deeppink">9-3-4、简写hasPubProperty</span>
			<ul>
				<li></li>
			</ul>
		</li>
	</ul>

</body>
</html>
<script type="text/javascript">
//3、变量提升具体解析************************************
	
	console.log(a,1) //打印undefined，全局执行上下文，全局下的变量提升
	console.log(func,2)//打印函数，全局执行上下文，函数会提前声明+定义
	var a = 10; //
	function func(){
		console.log(b,3); //打印undefined，局部执行上个文，b为私有变量，全局上下文不能直接使用私有变量
		var b = 20;
		console.log(b,4);
		y = 9000;
	}
	func();
	console.log(a,5);
	console.log(func,6)
	console.log(window.y)
	var cc = 112;
	var cc = 12333
	console.log(cc)

	if(false){
    var a1 = 1;
    let b1 = 2;
}
console.log(a1);
console.log(b1);
</script>