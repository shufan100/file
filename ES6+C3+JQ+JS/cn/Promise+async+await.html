<!DOCTYPE html>
<html>
<head>
	<title>	Promise</title>
</head>
<body>
	<button onclick="gets()">抽奖</button>
	<button onclick="getData()">ajax</button>
	<button onclick="main3()">async+await</button>
</body>
</html>
<script type="text/javascript">

	// resolve：成功调用
	// reject：失败调用

// 抽奖--------------------------------------
	function rand(n,m){
		return Math.ceil(Math.random() * (n-m+1)) + m-1;
	}
	const rands = (n,m) =>  Math.ceil(Math.random() * (n-m+1)) + m-1;
	function gets() {
		const p = new Promise((resolve,reject)=>{
			console.log('pending')
			setTimeout(()=>{
				let n = rands(1,100)
				console.log(n)
				if(n <= 30){
					resolve(n) // 将promise状态设置成功
				}else{
					reject(n)// 将promise状态设置失败
				}
			},500)
		})

		console.log(p)
		p.then(res=>{
			console.log(res,'==')
			alert('恭喜中奖，100万RMB!--'+ res)
		},(err)=>{
			console.log('再接再厉！--'+err)
		}).catch(err=>{
			console.log(err,'==')
		})
	}



//ajax请求封装-----------------------------
	function Ajaxs(path,type='POST') {
		return new Promise((resolve,reject)=>{
			const xhr = new XMLHttpRequest() //1、new一个xhr的实例对象
			xhr.open(type,path); // 2、初始化
			xhr.send();  // 3、发送 && 参数
			xhr.onreadystatechange = function(){ //4、处理响应结果
				console.log('readyState>>',xhr.readyState)
				// ===4是所有结果返回的状态
				if(xhr.readyState === 4){
					// 判断响应码为 2xx -- 成功响应
					if(xhr.status >=200 && xhr.status<300){
						resolve(JSON.parse(xhr.response))
					}else{
						// 失败响应
						reject(JSON.parse(xhr.response))
					}
				}
			}

		})
	} 
	function getData(){
		Ajaxs('https://api.apiopen.top/getJoke')
		.then(res=>{
			console.log(res,'---')
		},err=>{
			console.log(err,'===1')
		})
	}

// 封装函数返回一个promise对象------------------------------
	function fun() {

		return new Promise((resolve,reject)=>{
			if(false)  reject('错误数据') 
			resolve('成功数据')
		})
	}
	fun().then(res=>{
		console.log(res)
	},err=>{
		console.warn(err)
	})

// Promise.resolve使用(返回成功的Promise对象)-------------------------------------
	// 如果传入的参数 非promise类型的对象，则返回的结果为promise对象  ,fulfilled、resolved都是成功回调
	const p1 = Promise.resolve('resolve值')
	console.log(p1)
	
	// 如果传入的参数 为promise类型的对象，则将参数Promise返回的结果返回，其结果返回为promise对象
	const p2 = Promise.resolve(new Promise((resolve,reject)=>{
		resolve(true)
	}))
	console.log(p2)

	const p3 = Promise.resolve(new Promise((resolve,reject)=>{
		reject(false)
	}))
	p3.catch(err=>{ })
	console.log(p3)

// Promise.reject使用(返回失败的Promise对象)-------------------------------------
	const p4 = Promise.reject('reject值')
	p4.catch(err=>{})
	console.log(p4)

	const p5 = Promise.reject(new Promise((resolve,reject)=>{
		resolve(true)
	}))
	p5.catch(err=>{})
	console.log(p5)

//  Promise.all([]) -----------------------------------------
 	// 返回新的promise对象
	const promise1 = new Promise((resolve,reject)=>{
		resolve({name:'tom',age:19})
	})
	const promise2 = Promise.resolve('成功数据1111')
	const promise3 = Promise.resolve(new Promise((resolve,reject)=>{
		resolve([1,2,3,4])
	}))
	const promise4 = Promise.resolve(new Promise((resolve,reject)=>{
		// 同步
		reject([1,2,3,4,5,6])
	}))
	const promise5 = new Promise((resolve,reject)=>{
		// 异步
		setTimeout(()=>{
			resolve('ok')
		},1000)
	})


	// 成功all：3个都成功，则返回3个promise返回值的数组（新的promise）
	const result = Promise.all([promise1,promise2,promise3])
	console.log('result>>>',result) //成功：[{name:'tom',age:19}, '成功数据1111', [1,2,3,4] ]

	// 失败all：有一个promise失败就返回失败的promise的值（新的promise）
	const result2 = Promise.all([promise1,promise2,promise4])
	console.log('result2>>>',result2) //成功返回3个promise的成功返回值，有一个错误，就返回错误的promise


//  Promise.race([]) -----------------------------------------
	// 返回新的promise对象，根据第一个promise状态来，成功就成功，失败就失败
	// 如果第一个加了计数器需要等待，就按第二个promise状态来定
	
	//成功(同步任务)
    const result3 = Promise.race([promise1,promise2,promise3])
    console.log('result3>>>',result3) // {name:'tom',age:19}

    //失败(同步任务)
    const result4 = Promise.race([promise4,promise2,promise3])
    console.log('result4>>>',result4) // [1,2,3,4]

    //成功(异步任务)
    const result5 = Promise.race([promise5,promise2,promise3])
    console.log('result5>>>',result5) // 成功数据1111


// promise链式任务 + 中断promise链 -------------------------------------------~	
	// 中断promise链: 只有一种方法就是返回一个pending状态的promise 		
     let p22 = new Promise((resolve,reject)=>{ 
	    setTimeout(()=>{ resolve('ok') },1000) 
	})

	p22.then(res=>{
	    console.log(res)  // ok
	    return new Promise((resolve,reject)=>{
	        resolve('error')
	    })
	}).then(res=>{
	    console.log(res)   // success
	    return false
	}).then(res=>{
	    console.log(res,11)  // false 11
	    return new Promise(()=>{})  //中断promise链
	}).then(res=>{
	    console.log(res,22)  // undefined 22
	}).then(res=>{
	    console.log(res,33)  // undefined 33
	}).then(res=>{
	    console.log(res,44)  // undefined 44
	}).catch(err=>{
	    console.log(err) //error
	})
// promise解决回调地狱 -------------------------------------------~
	Ajaxs('https://api.apiopen.top/getJoke').then(res => {
      console.log(res, '1');
      return Ajaxs('https://api.apiopen.top/getJoke');
    }).then(res => {
      console.log(res, '2');
      return Ajaxs('https://api.apiopen.top/getJoke');
    }).then(res => {
      console.log(res, '3');
    }).catch(err => {
      console.log(err, '捕获接口的错误');
    });	


// ***************async+await*********************
	async function main(){ 
        // return false;  //如果返回值是一个非Pormise类型的数据，
        return new Promise((resolve,reject)=>{ //如果返回值是一个Pormise对象
            resolve('ok')        
        })
    }
    const m = main()  
    console.log(m)  //promiase对象


    async function main2(){
    	// 1、右侧为其它值
    	const res = await false;
    	// 2、右侧为promis对象 --成功
    	const res2 = await new Promise((resolve,reject)=>{  resolve('success1111') })
    	console.log(res,res2)  // false  success1111

    	// 3、右侧为promis对象 --失败
    	try{
    		var res3 = await new Promise((resolve,reject)=>{  reject('error1111') })
    	}catch(e){
    		console.log(e) //error1111
    	}

    	
    }
    main2()


    async function main3(){
    	try{
    		const res1= await Ajaxs('https://api.apiopen.top/getJoke')
	    	const res2= await Ajaxs('https://api.apiopen.top/getJoke1')
	    	const res3= await Ajaxs('https://api.apiopen.top/getJoke')
	    	console.log(res1,'----1---')
	    	console.log(res2,'----2---')
	    	console.log(res3,'----3---')
    	}catch(e){
    		console.log(e)
    	}
    	
    }
    // main3()
    

// ***************promise执行顺序*********************
// 同步(全局、promise函数体)  
// 异步(
// 		微任务：.then await执行后的返回值
// 		宏任务：setTimeout、setInterval、ajax、
// 		
// )

console.log(1)
async function main1(){
  await main2()
  console.log(2) //微任务，then
}

async function main2(){
  console.log(3)  // 这也是promise函数体
}
main1()
setTimeout(()=>{console.log(9)},100)
setTimeout(()=>{console.log(4)},0)

new Promise((resolve)=>{
  console.log(5)
  resolve() //加这个，promise才会走then方法
}).then(()=>{
  console.log(6)
}).then(()=>{
  console.log(7)
})

console.log(8)
console.warn('sssssssssssssssss')

// 1 3 5 8 2 6 7 4  9
// 

	// setImmediate(()=>{
	//   console.log(1)
	// })
	console.log(2)
	setTimeout(()=>{console.log(3)},0)//第一次放入任务队列中，事件循环加载，然后走setImmediate
	setTimeout(()=>{console.log(4)},100)//100毫秒后第二次放入任务队列中，所以这个打印在setImmediate后
	console.log(5)
	new Promise((resolve)=>{
	  console.log(6) // 同步
	  resolve() 	// 加这个，promise才会走then方法
	}).then(()=>{
	  console.log(7)
	})
	// process.nextTick(()=>{
	//   console.log(8)
	// })
// 输出：2、5、6、8、7、3、1、4

    
</script>