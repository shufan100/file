<!DOCTYPE html>
<html>
  <head>
    <title></title>
  </head>
  <body>
    <h2>浏览器运行机制：（大概）</h2>
  <ul>
    <li>1、为了让代码执行，浏览器会形成一个执行环境栈；</li>
    <li>2、有了栈内存就可以自上而下的执行了，刚开始是要把全局下的代码先执行；</li>
    <li>3、开始执行全局代码就会形成一个全局执行上下文</li>
    <li>4、对应代码会在自己所属的执行上下文中执行，而这个环境中有一个存在变量的地方</li>
  </ul>
  <p>补充：浏览器执行代码会变量提升，会给全局的var和fun函数先定义声明</p>

  <h2>全局对象和全局变量对象：（详细）</h2>
  <ul>
    <li>1、全局对象是浏览器自带的属性和方法的堆，是一个对象</li>
    <li>2、全局变量对象VO是我们自己创建的变量存储的地方，是栈内存</li>
  </ul>

  <h2>全局执行上下文：（详细）</h2>
  <ul>
    <li>在执行上下文中分为带var和不带var</li>
    <li>1-1：带var创建的变量是在 （全局变量对象VO）和（全局对象GO）中各存一份，但不会给全局对象GO添加属性<i>
    <li>2-1：不带var创建的变量只是在（全局对象GO）存一份,不带var而是全局对象GO的一个属性</li>
  </ul>

  <h2>function函数执行（私有执行上下文）：</h2>
  <ul>
    <li>1、函数每一次执行会创建一个全新的执行上下文，把执行上下文压缩到栈内存中去执行（进栈执行）</li>
    <li>2、在这个上下文中也会存一个AO（变量对象），用来存储当前上下文代码执行所创建的变量（私有变量)</li>
    <li>3、上下文中的代码执行完后，如果该上下文中的信息没有被外界占用的情况，执行完就会出栈，然后释放栈内存。</li>
  </ul>

  <h2>堆栈内存释放</h2>
  <ul>
    <li>1-1、堆内存：创建函数和创建对象的时候形成(把代码字符串和键值存到开辟的堆内存中)；</li>
    <li>1-2、堆内存释放:堆内存手动释放就要赋值为null,如果有变量或其他东西存储了堆内存的地址，就不能被释放；</li>
    <li>2-1、栈内存：打开浏览器形成的全局作用域，手动执行函数的私有作用域以及let/cosnt形成的块作用域；</li>
    <li>2-2、栈内存释放：全局栈内存关闭浏览器就可以销毁；私有栈内存一般在函数执行完成后被销毁</li>
    <li>3、浏览器有自动回收垃圾机制，定期间隔一段时间会把没被占用的内存回收释放</li>
  </ul>
  </body>
</html>
<script type="text/javascript">
  //JavaScript 主要运行在浏览器端

  // 什么是同源策略？
    //：同源策略是浏览器的一种安全机制，来限制不同源的网站不能通信.（同源：就是域名、协议、端口要一致） 
    
  // js的执行机制？
    // js是一个单线程、异步、非阻塞I/O模型，event loop事件循环的执行机制
    // 所以的任务分为两种：同步任务、异步任务。
    // ----同步任务是在主线程上排队执行的任务，前一个任务执行完才能执行下一个任务。
    // ----异步任务是不进入主线程，而进入任务队列任务，只有任务队列通知主线程，当某个异步任务可以执行了，才会进入主线程执行。
    
  // 运行栈执行顺序： 
  // 同步 》 nextTcik 》 异步（微任务 > 宏任务）
  //   1、同步（Promise的penning也是同步）(for循环)
  //   2、nextTick 
  //   3、异步（任务队列）
  //      3-1、微任务队列 （Promise的then）
  //      3-2、宏任务队列 （ajax,setTimeout,setInterval,读文件）
  //   4、setImmediate（计数器放在运行栈内，第一次栈内的事情循环加载完后就会触发）    





// 例子0
  // setImmediate(()=>{
  //   console.log(0)
  // })
  // console.log(1)
  // process.nextTick(()=>{
  //   console.log(2)
  // })
  // console.log(3)
  // setTimeout(()=>{console.log(4)},0)
  // console.log(5)

  // // 1，同步 2，nextTick 3,异步 4，setImmediate
  // // 如果是for循环也是先走完循环再走后面得，也算是同步
  // for (var i = 0; i < 2000; i++) {
  // 	console.log(1)
  // }
  // setTimeout(()=>{console.log(2)},0)
  // setTimeout(()=>{console.log(3)},0)
  // console.log(4)
  




// 例子1
  // 输出：2、5、6、8、7、3、1、4
  // 	setImmediate(()=>{
  // 	  console.log(1)
  // 	})
  // 	console.log(2)
  // 	setTimeout(()=>{console.log(3)},0)//第一次放入任务队列中，事件循环加载，然后走setImmediate
  // 	setTimeout(()=>{console.log(4)},100)//100毫秒后第二次放入任务队列中，所以这个打印再在setImmediate后
  // 	console.log(5)
  // 	new Promise((resolve)=>{
  // 	  console.log(6) // 同步
  // 	  resolve() 	// 加这个，promise才会走then方法
  // 	}).then(()=>{
  // 	  console.log(7)
  // 	})
  // 	process.nextTick(()=>{
  // 	  console.log(8)
  // 	})

  // let b = null
  // console.log(typeof(b))
  //
  
  

// 例子11
  // const p = new Promise(resolve => {
  //   console.log(1) //同步
  //   resolve('nihao') //resolve返回的值是then返回值的形参，一定要加这个，不然不会执行then
  // })
  // console.log(p) //promise对象
  // p.then(data => {
  //   console.log(data)
  //   console.log(2)
  // })
  // async function fun1() {
  //   let data = await fun2()
  //   console.log(data) //then中执行的代码
  // }
  // async function fun2() {
  //   console.log(22)
  //   return 11
  // }
  // fun1()

  console.error('-------------')

  
  

// 例子22
  setTimeout(function () {
    console.log(0) // 宏任务8
  }, 0)
  async function async1() {
    console.log(2) // 同步1
    const data = await async2()
    console.log(3) // 微任务 .then5
    return data
  }
  async function async2() {
    return new Promise(resolve => {
      console.log(4) // 同步2
      resolve('async2的结果')
    }).then(res => {
      console.log(5) // 微任务 .then3
      return res
    })
  }
  async1().then(res => {
    console.log(6) //微任务 .then6
    console.log(res) ////async2的结果7
  })
  new Promise(function (resolve) {
    console.log(7) //同步 3
  }).then(function () {
    console.log(8)
  })

  //2 4 5 3 6 async2的结果 7 0
  // 2 4 7 5 3 6 async2的结果  0
</script>

