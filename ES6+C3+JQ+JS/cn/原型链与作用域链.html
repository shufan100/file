<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>原型链与作用域链</title>
	<link rel="stylesheet" type="text/css" href="../css/reset.css">
</head>
<body>
	<p>2020.7.20总结:1、原型 普通函数有自带的显式原型prototype；构造函数是赋值到_proto_；2、原型链 查找函数的属性的过程</p>
	<p>2020.7.20总结:1、作用域 是对于变量的，分为局部和函数内部作用域；作用域链是当某个变量查找定义的时的过程</p>
</body>
</html>
<script src="../js/jquery.min.js"></script>
<script type="text/javascript">

// 1、原型、原型链***********
// 
	// 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象
	function Fun(){
		console.log(this)
		this.name = '熊明'
	} 		
	// 2. 每个实例对象都有一个__proto__，可称为隐式原型
	//创建实例对象
	const Fun1 = new Fun(); //隐式原型 _proto_

	Fun.prototype.code = '9993333'
	
	console.dir(Fun) // 打印函数，每个函数都有一个prototype的原型属性（空的对象）
	console.log(Fun1)//构造函数
	console.log(Fun1.code,Fun1.name) //这个查找的过程就叫原型链
	console.log(Fun1.__proto__ === Fun.prototype) // true 构造函数的隐性原型是继承的Fun函数的prototype显性原型

	
	/*1、原型链是针对构造函数的。
	2、所有声明的函数都有一个：prototype显式原型属性 //普通函数
	3、所有的new实例对象都有一个：_proto_隐式原型属性 //构造函数	
	4、显式原型与隐式原型关系： 
		4-1：函数的prototype:定义函数是就被自动赋值，值默认为{}，即为原型对象；
		4-2：实例对象的_proto_：在创建实例对象是被自动添加，并在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
  		4-3、原型对象即为当前实例对象的父对象
	5、**原型链：我们创建了一个函数，然后通过new这个函数赋值给一个变量，那么这个被new出来的函数就会继承创建出来的那个函数的属性，然后如果我访问new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个查找的过程就叫做原型链。
	*/
	function a(){};
	a.prototype.name = "追梦子";
	var b = new a(); //构造函数赋给变量的是个对象
	console.dir(a)
	console.log(b,b.name); //追梦子
	console.log(b.__proto__.name === a.prototype.name) //构造函数的隐式原型 === 普通函数的原型对象

	function Person(){
	}
	Person.prototype.name = "Nicholas";
	Person.prototype.age = 29;
	Person.prototype.job = "Software Engineer";
	Person.prototype.sayName = function(){
		alert(this.name);
	};

	function Person1(){
	}
	Person1.prototype.name1 = "111";
	console.dir(Person1)

	var person1 = new Person();
	var person2 = new Person();
	person1.__proto__.code = '129';
	person1.__proto__.name = '11sdd';

	console.dir(Person)
	console.log(person1,'构造函数',person2)
	console.log(Person.prototype.code == person1.code)
	console.log(Person.prototype.code == person2.code)
	console.log(person1.code == person2.code)

	let accs = function(){
		console.log(1123)
	}
	accs();
	
// 2、作用域、作用域链****************
	/* 1、作用域是针对变量的。2、作用域分为两种：全局作用域、函数作用域。
	3、作用域的特点：在自己的变量范围中查找，如果找不到就沿着作用域往上找。 
	4、作用域链：a最后打印出来的是3，因为执行函数c（）的时候它在自己的范围内找到了变量a所以就不会越上继续查找，
	如果在函数c()中没有找到则会继续向上找，一直会找到全局变量a，这个查找的过程就叫作用域链。作用域只会向上查找*/
	// 函数被调用时，都会创建一个执行环境以及相应的作用域链。
	var a = 1;
var b  = 11
console.log(a,b)
function fun1() {
	let val = 'ppp'
	a = 2
	var a
	console.log(a,val)  //输出2
	function fun2() {
		   
		val = 'kkk'
		 console.log(a,val)  //输出3  // 函数内部作用域
a = 3;
		b = 22    
		 console.log(a,b) // 输出22   // 全局作用域 ，b变量一层一层往上走的过程叫做作用域链
	}
	fun2()
 }

fun1()
console.log(a,b)
</script>